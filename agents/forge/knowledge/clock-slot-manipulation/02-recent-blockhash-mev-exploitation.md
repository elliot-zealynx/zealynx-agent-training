# Recent Blockhash MEV Exploitation

## Description

Transactions include a `recentBlockhash` field that limits validity to roughly the last 150 blocks (~60 seconds). This creates MEV opportunities and timing attack vectors.

## Vulnerability Pattern

Smart contracts that don't account for transaction timing windows can be exploited through strategic transaction ordering within the blockhash validity period.

## Vulnerable Code Example

```rust
use solana_program::{
    account_info::AccountInfo,
    pubkey::Pubkey,
    msg,
};

#[derive(Clone)]
pub struct AuctionData {
    pub highest_bid: u64,
    pub highest_bidder: Pubkey,
    pub end_slot: u64,
}

// VULNERABLE: No protection against last-block manipulation
pub fn place_bid(accounts: &[AccountInfo], bid_amount: u64) -> Result<(), ProgramError> {
    let clock = Clock::get()?;
    let auction = AuctionData::try_from_slice(&accounts[0].data.borrow())?;
    
    // Vulnerable: Can be exploited in final blocks
    if clock.slot >= auction.end_slot {
        return Err(ProgramError::InvalidInstructionData);
    }
    
    if bid_amount > auction.highest_bid {
        // Update auction state - vulnerable to MEV
        msg!("New highest bid: {} at slot {}", bid_amount, clock.slot);
        update_highest_bid(accounts, bid_amount)?;
    }
    
    Ok(())
}

// VULNERABLE: Immediate execution without delay
pub fn execute_trade(accounts: &[AccountInfo]) -> Result<(), ProgramError> {
    let price_account = &accounts[1];
    let oracle_price = get_oracle_price(price_account)?;
    
    // Vulnerable: Can be front-run within blockhash window
    execute_swap_at_price(accounts, oracle_price)?;
    
    Ok(())
}
```

## Attack Vector

1. **Last-Block Auction Sniping**: Submit bid in final valid block to prevent counter-bids
2. **Front-Running within Window**: Use 150-block validity to time advantageous trades
3. **Bundle-Leak Exploitation**: Monitor relay bundles to pre-position transactions
4. **Cross-Block MEV**: Coordinate across multiple blocks within validity window

## Real-World Examples

- **Auction Protocols**: Last-second bids that can't be countered due to blockhash expiry
- **DEX Arbitrage**: Using blockhash timing to guarantee profitable arbitrage execution
- **Liquidation MEV**: Timing liquidations to maximize extraction within validity window
- **Bridge Timing Attacks**: Exploiting cross-chain bridge settlement timing

## Detection Strategy

```rust
// Check for auction/timing-sensitive logic
grep -r "end_slot\|auction\|deadline" src/
grep -r "execute_trade\|swap\|liquidate" src/

// Look for immediate execution patterns
grep -r "Clock::get" src/ | grep -v "validation"
```

## Secure Implementation

```rust
use solana_program::{
    account_info::AccountInfo,
    clock::Clock,
    sysvar::Sysvar,
    msg,
};

const MINIMUM_BID_DELAY_SLOTS: u64 = 10; // Prevent last-second bids
const EXECUTION_DELAY_SLOTS: u64 = 5;    // Delay immediate execution

#[derive(Clone)]
pub struct SecureAuctionData {
    pub highest_bid: u64,
    pub highest_bidder: Pubkey,
    pub end_slot: u64,
    pub last_bid_slot: u64,
}

// Secure: Buffer against last-block manipulation
pub fn secure_place_bid(accounts: &[AccountInfo], bid_amount: u64) -> Result<(), ProgramError> {
    let clock = Clock::get()?;
    let auction = SecureAuctionData::try_from_slice(&accounts[0].data.borrow())?;
    
    // Secure: End bidding before actual end to prevent sniping
    if clock.slot + MINIMUM_BID_DELAY_SLOTS >= auction.end_slot {
        msg!("Bidding closed - too close to end slot");
        return Err(ProgramError::InvalidInstructionData);
    }
    
    if bid_amount > auction.highest_bid {
        // Store slot to track bid timing
        let mut updated_auction = auction.clone();
        updated_auction.highest_bid = bid_amount;
        updated_auction.last_bid_slot = clock.slot;
        
        serialize_auction(accounts, &updated_auction)?;
    }
    
    Ok(())
}

#[derive(Clone)]
pub struct DelayedTradeData {
    pub trade_request_slot: u64,
    pub requested_price: u64,
    pub executed: bool,
}

// Secure: Delayed execution to prevent front-running
pub fn request_trade(accounts: &[AccountInfo], max_price: u64) -> Result<(), ProgramError> {
    let clock = Clock::get()?;
    
    let trade_data = DelayedTradeData {
        trade_request_slot: clock.slot,
        requested_price: max_price,
        executed: false,
    };
    
    // Store trade request - execution happens later
    serialize_trade_request(accounts, &trade_data)?;
    msg!("Trade requested at slot: {}", clock.slot);
    
    Ok(())
}

pub fn execute_delayed_trade(accounts: &[AccountInfo]) -> Result<(), ProgramError> {
    let clock = Clock::get()?;
    let trade_data = DelayedTradeData::try_from_slice(&accounts[0].data.borrow())?;
    
    // Secure: Enforce execution delay
    if clock.slot < trade_data.trade_request_slot + EXECUTION_DELAY_SLOTS {
        return Err(ProgramError::InvalidInstructionData);
    }
    
    if trade_data.executed {
        return Err(ProgramError::AlreadyInUse);
    }
    
    // Execute with original price constraints
    execute_with_price_check(accounts, trade_data.requested_price)?;
    
    Ok(())
}
```

## Mitigation Strategies

1. **Execution Delays**: Introduce minimum delays between request and execution
2. **Early Cutoffs**: End time-sensitive operations before actual deadlines
3. **Commit-Reveal Schemes**: Use two-phase transactions for sensitive operations
4. **Price Slippage Protection**: Set maximum acceptable slippage for trades
5. **Anti-MEV Design**: Structure protocols to minimize MEV extraction opportunities

## MEV Protection Patterns

```rust
// Pattern 1: Time locks for sensitive operations
const MIN_DELAY_SLOTS: u64 = 5;

// Pattern 2: Randomized execution windows
fn get_randomized_delay(base_slot: u64) -> u64 {
    // Use slot hash as entropy source
    (base_slot % 10) + 5  // 5-15 slot delay
}

// Pattern 3: Batch execution to reduce timing attacks
pub struct BatchedExecution {
    pub requests: Vec<TradeRequest>,
    pub execution_slot: u64,
}
```

## References

- [Adevar Labs: MEV on Solana](https://www.adevarlabs.com/blog/unpacking-mev-on-solana-challenges-threats-and-developer-defenses)
- [bloXroute: New Era of MEV on Solana](https://medium.com/bloxroute/a-new-era-of-mev-on-solana-ae5cff390b71)
- [Solana Transaction Structure Documentation](https://docs.solana.com/developing/programming-model/transactions)