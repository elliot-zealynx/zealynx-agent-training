# Permit Signature Exploitation

**Severity:** HIGH/CRITICAL  
**Category:** Approval/Allowance Bugs  
**Gas Impact:** Low  
**Frequency:** Growing (EIP-2612 adoption)  

## Description

EIP-2612 permit() functions allow gasless approvals via signatures, but improper validation or replay protection can lead to signature hijacking, replay attacks, and unauthorized token approvals. Malicious contracts can trick users into signing permits that grant excessive permissions.

## Vulnerable Code Example

```solidity
contract VulnerablePermitHandler {
    function depositWithPermit(
        IERC20Permit token,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // VULNERABILITY: No validation of permit parameters
        // Attacker can get user to sign permit for more than amount
        token.permit(msg.sender, address(this), amount, deadline, v, r, s);
        token.transferFrom(msg.sender, address(this), amount);
    }
}

contract PermitPhishing {
    function maliciousPermit(
        IERC20Permit token,
        address victim,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // User signed permit for type(uint256).max thinking it was for small amount
        token.permit(victim, address(this), type(uint256).max, deadline, v, r, s);
        
        // Now can drain all tokens
        uint256 balance = token.balanceOf(victim);
        token.transferFrom(victim, msg.sender, balance);
    }
}
```

## Detection Strategy

**Static Analysis:**
- Check permit() parameter validation
- Look for mismatched permit amount vs actual usage
- Flag missing deadline validation
- Identify permit signature replay opportunities

**Dynamic Analysis:**
- Test permit with manipulated parameters
- Verify signature validation logic
- Check permit expiry handling

**Code Review Focus:**
- Frontend permit signature construction
- Permit parameter validation in contracts
- Signature replay protection mechanisms
- User education around permit signing

## Fix Pattern

**Secure Permit Handling:**
```solidity
contract SecurePermitHandler {
    mapping(bytes32 => bool) public usedPermits;
    
    function depositWithPermit(
        IERC20Permit token,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // Validate deadline
        require(block.timestamp <= deadline, "Permit expired");
        
        // Validate amount matches expected usage
        require(amount > 0 && amount <= maxDepositAmount, "Invalid permit amount");
        
        // Create permit hash for replay protection
        bytes32 permitHash = keccak256(abi.encodePacked(
            msg.sender, address(this), amount, deadline, v, r, s
        ));
        require(!usedPermits[permitHash], "Permit already used");
        usedPermits[permitHash] = true;
        
        // Use exact permit amount
        token.permit(msg.sender, address(this), amount, deadline, v, r, s);
        token.transferFrom(msg.sender, address(this), amount);
    }
}
```

**Safe Permit Library:**
```solidity
library SafePermit {
    function safePermit(
        IERC20Permit token,
        address owner,
        address spender,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        // Check if permit is needed
        uint256 currentAllowance = token.allowance(owner, spender);
        if (currentAllowance >= amount) {
            return; // Sufficient allowance already exists
        }
        
        // Validate deadline
        require(block.timestamp <= deadline, "SafePermit: expired deadline");
        
        // Attempt permit, handle failures gracefully
        try token.permit(owner, spender, amount, deadline, v, r, s) {
            // Success
        } catch {
            // Permit failed, check if allowance was set anyway
            require(
                token.allowance(owner, spender) >= amount,
                "SafePermit: permit failed and insufficient allowance"
            );
        }
    }
}
```

## Real Examples

1. **Uniswap Permit2** - Comprehensive permit system with proper validation
2. **1inch Limit Orders** - Uses permit signatures for gasless trading
3. **Euler Finance** - Had permit-related vulnerabilities in early versions
4. **Various DEX Aggregators** - Multiple permit signature issues discovered

## Exploitation Scenarios

**Signature Hijacking:**
```solidity
// Attacker tricks user into signing permit for large amount
// by hiding it in "innocent" transaction
contract PermitTrap {
    function "innocent_function"() external {
        // User thinks they're signing for small operation
        // But actually signing permit for max amount to attacker
    }
}
```

**Cross-Chain Replay:**
```solidity
// If permit doesn't include chain ID validation
// Signature can be replayed on different networks
```

## Prevention Best Practices

1. **Validate all permit parameters** before execution
2. **Use exact amounts** - never permit more than needed
3. **Implement proper deadline validation**
4. **Add replay protection** for critical operations
5. **Educate users** about permit signature risks
6. **Use battle-tested libraries** like Permit2
7. **Include chain ID** in signature validation
8. **Handle permit failures gracefully**

## Frontend Security

**Safe Permit Construction:**
```javascript
// Always show exact permit parameters to user
const permitData = {
    owner: userAddress,
    spender: contractAddress,
    amount: exactAmount, // Never type(uint256).max
    deadline: reasonableDeadline // 20 minutes, not years
};

// Clear UI showing what user is signing
console.log(`Permitting ${formatAmount(amount)} tokens to ${contractName}`);
```

## Gas Optimization vs Security

- Permit saves gas vs approve() transactions
- But adds signature validation overhead
- Consider permit caching for repeated operations
- Balance between UX and security

## Related Patterns

- Infinite Approval
- Approval Front-Running
- Signature Replay Attacks
- Meta-Transaction Exploits