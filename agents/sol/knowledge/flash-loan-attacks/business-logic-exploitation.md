# Flash Loan: Business Logic Exploitation

## Description
Flash loans amplify the impact of complex business logic flaws by providing attackers with unlimited capital to trigger edge cases. Unlike simple oracle manipulation, these attacks exploit subtle interactions between multiple protocol functions, often involving:

- Liquidation mechanics
- Interest rate calculations
- Collateral factor manipulations
- Cross-function state inconsistencies
- Reward distribution flaws

The flash loan provides the capital to hit unlikely but exploitable states.

## Vulnerable Code Pattern

```solidity
// VULNERABLE: Complex liquidation logic with state inconsistency
contract VulnerableLending {
    mapping(address => uint256) public collateral;
    mapping(address => uint256) public debt;
    mapping(address => uint256) public rewards;
    
    function borrow(uint256 amount) external {
        require(isHealthy(msg.sender), "Unhealthy position");
        debt[msg.sender] += amount;
        
        // VULNERABLE: State check BEFORE interest accrual
        // Attacker can borrow more than allowed if interest hasn't been updated
        token.transfer(msg.sender, amount);
    }
    
    function liquidate(address user, uint256 repayAmount) external {
        require(!isHealthy(user), "Position healthy");
        
        // VULNERABLE: Liquidation bonus based on current state
        // Can be manipulated if rewards are distributed during liquidation
        uint256 bonus = calculateBonus(user);
        uint256 collateralSeized = repayAmount * bonus / 1e18;
        
        // DANGEROUS: This can trigger reward distribution
        _updateRewards(user);
        
        collateral[user] -= collateralSeized;
        debt[user] -= repayAmount;
        
        // Attacker receives more collateral than expected
        token.transfer(msg.sender, collateralSeized);
    }
    
    // VULNERABLE: Separate function updates that should be atomic
    function accrueInterest() external {
        // Interest accrued globally but individual positions not updated
        globalInterestIndex = calculateNewIndex();
    }
}
```

## Detection Strategy

1. **Map all state transitions**: Create a state machine of all possible function calls
2. **Find invariant violations**: What properties should ALWAYS hold? Can they be violated?
3. **Check for ordering dependencies**: Do functions assume specific call ordering?
4. **Cross-function analysis**: Can calling A then B produce different results than B then A?
5. **Interest/reward accrual**: Are updates atomic with position changes?
6. **Liquidation mechanics**: Can attackers self-liquidate profitably?

Questions to ask:
- Can a user be liquidated while appearing healthy?
- Can rewards be claimed multiple times?
- Are all balances updated atomically?
- Can circular borrowing create leverage beyond limits?

## Fix Pattern

```solidity
// SECURE: Atomic state updates with invariant checks
contract SecureLending {
    uint256 public globalInterestIndex;
    
    struct Position {
        uint256 collateral;
        uint256 debt;
        uint256 interestIndexSnapshot;  // Track when interest was last applied
        uint256 lastUpdate;
    }
    
    mapping(address => Position) public positions;
    
    // SECURE: Always accrue interest before any operation
    modifier accrueFirst(address user) {
        _accrueUserInterest(user);
        _;
        _checkInvariants(user);
    }
    
    function _accrueUserInterest(address user) internal {
        Position storage pos = positions[user];
        if (pos.interestIndexSnapshot < globalInterestIndex) {
            uint256 interestMultiplier = globalInterestIndex * 1e18 / pos.interestIndexSnapshot;
            pos.debt = pos.debt * interestMultiplier / 1e18;
            pos.interestIndexSnapshot = globalInterestIndex;
        }
    }
    
    function borrow(uint256 amount) external accrueFirst(msg.sender) {
        Position storage pos = positions[msg.sender];
        pos.debt += amount;
        
        // SECURE: Check health AFTER all state updates
        require(_isHealthy(msg.sender), "Would be unhealthy");
        
        token.transfer(msg.sender, amount);
    }
    
    function liquidate(address user, uint256 repayAmount) external 
        accrueFirst(user) 
        accrueFirst(msg.sender) 
    {
        require(!_isHealthy(user), "Position healthy");
        
        Position storage pos = positions[user];
        
        // SECURE: Calculate all values BEFORE any state changes
        uint256 bonus = LIQUIDATION_BONUS;  // Fixed, not calculated from state
        uint256 collateralSeized = repayAmount * bonus / 1e18;
        
        require(collateralSeized <= pos.collateral, "Insufficient collateral");
        
        // SECURE: All state updates together
        pos.collateral -= collateralSeized;
        pos.debt -= repayAmount;
        
        // SECURE: Invariant check
        require(pos.debt == 0 || pos.collateral > 0, "Invalid state");
        
        token.transfer(msg.sender, collateralSeized);
    }
    
    function _checkInvariants(address user) internal view {
        Position storage pos = positions[user];
        // Add protocol-specific invariants here
        assert(pos.collateral == 0 || pos.interestIndexSnapshot == globalInterestIndex);
    }
}
```

## Real Examples

### Euler Finance ($197M - March 2023)
- **Attack**: Exploited complex interaction between donation, liquidation, and eToken minting
- **Method**: Created a self-collateralizing position, donated to create bad debt
- **Logic flaw**: Donation function didn't properly account for liquidation health
- **Root cause**: Multiple interacting systems with inconsistent state assumptions
- **Reference**: https://www.rekt.news/euler-rekt/

### Hundred Finance ($7M - April 2023)
- **Attack**: Exploited empty market + donation + borrow interaction
- **Method**: Became sole supplier in empty market, manipulated exchange rate
- **Logic flaw**: Share/exchange rate calculation in empty pool edge case
- **Root cause**: Compound V2 fork without proper first-depositor protection
- **Reference**: https://www.certik.com/resources/blog/hundred-finance

### Platypus Finance ($8.5M - February 2023)
- **Attack**: Exploited interaction between borrowing and staking
- **Method**: Borrowed USP, used flash loan to manipulate collateral ratio during unstake
- **Logic flaw**: Health check timing in unstake function
- **Root cause**: Position could become unhealthy between check and effect
- **Reference**: https://www.rekt.news/platypus-rekt/

### Sentiment Protocol ($1M - April 2023)
- **Attack**: Reentrancy through Balancer flash loan callback
- **Method**: Called `flashLoan` which triggered callback before state update
- **Logic flaw**: Assumed flash loan callback wouldn't re-enter protocol
- **Root cause**: External call (Balancer flash loan) allowed reentrancy
- **Reference**: https://www.halborn.com/blog/sentiment-protocol

## Additional Mitigations

1. **State machine verification**: Formally verify all state transitions
2. **Invariant assertions**: Add `assert()` statements for critical properties
3. **Atomic operations**: Group related state changes in single functions
4. **Reentrancy protection**: Apply `nonReentrant` to all external functions
5. **Health checks**: Always check position health AFTER state changes
6. **Time-based protections**: Require minimum time between certain operations
7. **Circuit breakers**: Pause if unusual activity detected
8. **Comprehensive testing**: Include multi-tx attack scenarios in tests
9. **Interest accrual**: Always accrue before any position-modifying operation
10. **Fork audits**: If forking (Compound, Aave), audit fork-specific changes thoroughly
